{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6********","webpack:///js/router.js","webpack:///webpack/bootstrap cd006e37c05cd60bbe97?7de2********","webpack:///./~/vue-router/dist/vue-router.esm.js","webpack:///./src/lib/router/router.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","144","__webpack_exports__","warn","condition","message","console","resolveProps","route","config","params","undefined","resolveQuery","query","extraQuery","parsedQuery","parseQuery","e","key","res","trim","replace","split","forEach","param","parts","decode","shift","val","length","join","Array","isArray","push","stringifyQuery","obj","keys","map","encode","result","slice","val2","filter","x","createRoute","record","location","redirectedFrom","meta","path","hash","fullPath","getFullPath","matched","formatMatch","freeze","unshift","parent","ref","isSameRoute","a","b","START","trailingSlashRE","isObjectEqual","aKeys","bKeys","every","String","isIncludedRoute","current","target","indexOf","queryIncludes","guardEvent","metaKey","ctrlKey","shiftKey","defaultPrevented","button","getAttribute","test","preventDefault","findAnchor","children","child","tag","install","Vue","installed","_Vue","$root","_router","_route","mixin","beforeCreate","$options","router","init","util","defineReactive","history","component","View","Link","strats","optionMergeStrategies","beforeRouteEnter","beforeRouteLeave","created","resolvePath","relative","base","append","charAt","stack","pop","segments","segment","parsePath","hashIndex","queryIndex","cleanPath","createRouteMap","routes","oldPathMap","oldNameMap","pathMap","create","nameMap","addRouteRecord","matchAs","normalizePath","components","default","instances","redirect","beforeEnter","props","alias","aliasRoute","parse","str","options","tokens","index","defaultDelimiter","delimiter","PATH_REGEXP","exec","escaped","offset","next","prefix","capture","group","modifier","asterisk","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","charCodeAt","toString","toUpperCase","encodeAsterisk","matches","RegExp","opts","data","pretty","encodeURIComponent","token","TypeError","isarray","JSON","stringify","j","attachKeys","re","flags","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","strict","end","endsWithDelimiter","getRouteRegex","regexp","hit","regexpCache","fillParams","routeMsg","regexpCompileCache","normalizeLocation","raw","_normalized","assign","rawPath","parsedPath","basePath","createMatcher","addRoutes","currentRoute","paramNames","_createRoute","matchRoute","originalRedirect","resolveRecordPath","aliasedPath","aliasedMatch","aliasedRecord","pathname","len","decodeURIComponent","setupScroll","window","addEventListener","saveScrollPosition","state","setStateKey","handleScroll","to","from","isPop","app","behavior","scrollBehavior","$nextTick","position","getScrollPosition","shouldScroll","isObject","selector","el","document","querySelector","getElementPosition","isValidPosition","normalizePosition","scrollTo","y","getStateKey","positionStore","pageXOffset","pageYOffset","docEl","documentElement","docRect","getBoundingClientRect","elRect","left","top","isNumber","v","genKey","Time","now","toFixed","_key","pushState","url","replaceState","runQueue","queue","fn","cb","step","normalizeBase","inBrowser","baseEl","resolveQueue","max","Math","updated","activated","deactivated","extractGuards","records","bind","reverse","guards","flatMapComponents","def","instance","guard","extractGuard","flatten","extend","extractLeaveGuards","bindGuard","extractUpdateHooks","apply","arguments","extractEnterGuards","cbs","isValid","_","bindEnterGuard","poll","setTimeout","resolveAsyncComponents","resolve","once","resolvedDef","reject","reason","then","arr","concat","called","getLocation","search","checkFallback","ensureSlash","getHash","replaceHash","href","pushHash","createHref","mode","functional","type","render","h","routerView","$route","cache","_routerViewCache","depth","inactive","$vnode","_inactive","$parent","routerViewDepth","hooks","hook","vnode","prepatch","oldVnode","destroy","encodeReserveReplacer","toTypes","eventTypes","required","exact","Boolean","activeClass","event","this$1","$router","classes","linkActiveClass","compareTarget","handler","on","click","class","attrs","$slots","isStatic","index$1","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","supportsPushState","ua","navigator","userAgent","performance","Date","History","pending","ready","readyCbs","listen","onReady","transitionTo","onComplete","onAbort","confirmTransition","updateRoute","ensureURL","abort","beforeHooks","iterator","postEnterCbs","prev","afterHooks","HTML5History","History$$1","expectScroll","__proto__","constructor","go","getCurrentLocation","HashHistory","fallback","setupListeners","AbstractHistory","targetIndex","VueRouter","apps","matcher","prototypeAccessors","setupHashListener","beforeEach","afterEach","back","forward","getMatchedComponents","normalizedTo","resolved","defineProperties","version","use","153","__WEBPACK_IMPORTED_MODULE_0_vue_router__","ggRouter","option","configRouter","jsonRouter","TYPE_ROUTER_PUSH","routerExe","TYPE_ROUTER_REPLACE","f_name","f_params","f_type","F_DATA","num","array","rArray","ob","setJsonRouter"],"mappings":"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","file":"js/router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"router\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"router\"] = factory();\n\telse\n\t\troot[\"router\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 153);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 144:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n  * vue-router v2.2.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // inject instance registration hooks\n    var hooks = data.hook || (data.hook = {});\n    hooks.init = function (vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.prepatch = function (oldVnode, vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.destroy = function (vnode) {\n      if (matched.instances[name] === vnode.child) {\n        matched.instances[name] = undefined;\n      }\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more comformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery;\n    try {\n      parsedQuery = parseQuery(query);\n    } catch (e) {\n      \"production\" !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n    var compareTarget = location.path ? createRoute(null, location) : route;\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.target && e.target.getAttribute) {\n    var target = e.target.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this.$root._route }\n  });\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathMap,\n  oldNameMap\n) {\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route);\n  });\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (false) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (false) {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n      });\n    } else {\n      var aliasRoute = {\n        path: route.alias,\n        children: route.children\n      };\n      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (false) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null);\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path];\n  var keys, regexp;\n\n  if (hit) {\n    keys = hit.keys;\n    regexp = hit.regexp;\n  } else {\n    keys = [];\n    regexp = index(path, keys);\n    regexpCache[path] = { keys: keys, regexp: regexp };\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (false) {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (false) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/';\n  var query = resolveQuery(parsedPath.query, next.query);\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (false) {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      \"production\" !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      );\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (false) {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) { params[key.name] = val; }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (false) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        position = getElementPosition(el);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n  }\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, onAbort);\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function () { onAbort && onAbort(); };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true);\n        abort();\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n        abort();\n      } else {\n        // confirm transition and pass on the value\n        next(to);\n      }\n    });\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  return function boundRouteGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = once(function (resolvedDef) {\n          match.components[key] = resolvedDef;\n          next();\n        });\n\n        var reject = once(function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n          next(false);\n        });\n\n        var res = def(resolve, reject);\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject);\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (called) { return }\n    called = true;\n    return fn.apply(this, arguments)\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, this$1.current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#');\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  );\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || []);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (false) {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  \"production\" !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn);\n};\n\nVueRouter.prototype.onReady = function onReady (cb) {\n  this.history.onReady(cb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(to, current || this.history.current, append);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.2.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (VueRouter);\n\n\n/***/ }),\n\n/***/ 153:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_router__ = __webpack_require__(144);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"VueRouter\", function() { return __WEBPACK_IMPORTED_MODULE_0_vue_router__[\"a\"]; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ggRouter\", function() { return ggRouter; });\n/**\r\n * Created by mark on 2017/3/6.\r\n */\n\n\nfunction router() {\n\n    var TYPE_ROUTER_PUSH = '1';\n    var TYPE_ROUTER_REPLACE = '2';\n    var jsonRouter;\n    var router;\n\n    function install(Vue, option) {\n        Vue.use(__WEBPACK_IMPORTED_MODULE_0_vue_router__[\"a\" /* default */]);\n        Vue.prototype.ggRouter = {\n            push: push,\n            replace: replace,\n            go: go,\n            configRouter: configRouter,\n            jsonRouter: jsonRouter\n        };\n\n        router = option['router'];\n    }\n\n    /*\r\n     input:\r\n     data:json={\r\n     f_name:string\r\n     f_params:json\r\n     }\r\n     */\n\n    function push(data) {\n        data['f_type'] = TYPE_ROUTER_PUSH;\n        routerExe(data);\n    }\n\n    /*\r\n     input:\r\n     data:json={\r\n     f_name:string\r\n     f_params:json\r\n     }\r\n     */\n    function replace(data) {\n        data['f_type'] = TYPE_ROUTER_REPLACE;\n        routerExe(data);\n    }\n\n    /*\r\n     input:\r\n    data:json={\r\n     f_name:string\r\n     f_params:json\r\n     f_type:string 1=>push,2=>replace\r\n    }\r\n     */\n    function routerExe(data) {\n        var f_name = data['f_name'];\n        var f_params = data['f_params'];\n        var f_type = data['f_type'];\n        var obj;\n\n        if (f_params == undefined) f_params = {};\n\n        obj = {\n            name: f_name,\n            params: {\n                F_DATA: JSON.stringify(f_params)\n            }\n        };\n\n        if (f_type == TYPE_ROUTER_PUSH) router.push(obj);else if (f_type == TYPE_ROUTER_REPLACE) router.push(obj);\n    }\n\n    /*\r\n    input:\r\n    data:json={\r\n     f_num:int  defalt -1\r\n    }\r\n     */\n    function go(data) {\n        var num = -1;\n        if (data != undefined) num = data['f_num'];\n        router.go(num);\n    }\n    /*\r\n    input:\r\n    data:json={\r\n       array:json array=[\r\n        {\r\n         name:string,\r\n         componet:.vue class\r\n        }\r\n       ]\r\n    }\r\n    out:router array\r\n     */\n    function configRouter(data) {\n        var array = data['array'];\n        var rArray = [];\n        array.forEach(function (obj) {\n            var name = obj['name'];\n            var component = obj['component'];\n            var ob = {\n                path: \"/\" + name + \"/:F_DATA?\",\n                name: name,\n                component: component\n            };\n            rArray.push(ob);\n        });\n\n        return rArray;\n    }\n\n    function setJsonRouter(value) {\n        jsonRouter = value;\n    }\n\n    return {\n        install: install,\n        configRouter: configRouter,\n        setJsonRouter: setJsonRouter\n    };\n}\n\nvar ggRouter = router();\n\n\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// js/router.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 153);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cd006e37c05cd60bbe97","/**\n  * vue-router v2.2.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // inject instance registration hooks\n    var hooks = data.hook || (data.hook = {});\n    hooks.init = function (vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.prepatch = function (oldVnode, vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.destroy = function (vnode) {\n      if (matched.instances[name] === vnode.child) {\n        matched.instances[name] = undefined;\n      }\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more comformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery;\n    try {\n      parsedQuery = parseQuery(query);\n    } catch (e) {\n      process.env.NODE_ENV !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n    var compareTarget = location.path ? createRoute(null, location) : route;\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.target && e.target.getAttribute) {\n    var target = e.target.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this.$root._route }\n  });\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathMap,\n  oldNameMap\n) {\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route);\n  });\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n      });\n    } else {\n      var aliasRoute = {\n        path: route.alias,\n        children: route.children\n      };\n      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null);\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path];\n  var keys, regexp;\n\n  if (hit) {\n    keys = hit.keys;\n    regexp = hit.regexp;\n  } else {\n    keys = [];\n    regexp = index(path, keys);\n    regexpCache[path] = { keys: keys, regexp: regexp };\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/';\n  var query = resolveQuery(parsedPath.query, next.query);\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      process.env.NODE_ENV !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      );\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) { params[key.name] = val; }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        position = getElementPosition(el);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n  }\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, onAbort);\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function () { onAbort && onAbort(); };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true);\n        abort();\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n        abort();\n      } else {\n        // confirm transition and pass on the value\n        next(to);\n      }\n    });\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  return function boundRouteGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = once(function (resolvedDef) {\n          match.components[key] = resolvedDef;\n          next();\n        });\n\n        var reject = once(function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n          next(false);\n        });\n\n        var res = def(resolve, reject);\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject);\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (called) { return }\n    called = true;\n    return fn.apply(this, arguments)\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, this$1.current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#');\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  );\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || []);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn);\n};\n\nVueRouter.prototype.onReady = function onReady (cb) {\n  this.history.onReady(cb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(to, current || this.history.current, append);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.2.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\nexport default VueRouter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-router/dist/vue-router.esm.js\n// module id = 144\n// module chunks = 9","/**\r\n * Created by mark on 2017/3/6.\r\n */\r\nimport VueRouter from 'vue-router'\r\n\r\nfunction router() {\r\n\r\n    const TYPE_ROUTER_PUSH='1';\r\n    const TYPE_ROUTER_REPLACE='2';\r\n    var jsonRouter;\r\n    var router;\r\n\r\n    function install(Vue,option) {\r\n        Vue.use(VueRouter);\r\n        Vue.prototype.ggRouter = {\r\n            push:push,\r\n            replace:replace,\r\n            go:go,\r\n            configRouter:configRouter,\r\n            jsonRouter:jsonRouter,\r\n        }\r\n\r\n        router=option['router'];\r\n    }\r\n\r\n    /*\r\n     input:\r\n     data:json={\r\n     f_name:string\r\n     f_params:json\r\n     }\r\n     */\r\n\r\n    function push(data) {\r\n        data['f_type']=TYPE_ROUTER_PUSH;\r\n        routerExe(data);\r\n    }\r\n\r\n    /*\r\n     input:\r\n     data:json={\r\n     f_name:string\r\n     f_params:json\r\n     }\r\n     */\r\n    function replace(data) {\r\n        data['f_type']=TYPE_ROUTER_REPLACE;\r\n        routerExe(data);\r\n    }\r\n\r\n    /*\r\n     input:\r\n    data:json={\r\n     f_name:string\r\n     f_params:json\r\n     f_type:string 1=>push,2=>replace\r\n    }\r\n     */\r\n    function routerExe(data) {\r\n        var f_name = data['f_name'];\r\n        var f_params = data['f_params'];\r\n        var f_type=data['f_type'];\r\n        var obj;\r\n\r\n        if(f_params==undefined)\r\n            f_params={}\r\n\r\n         obj={\r\n            name:f_name,\r\n             params:{\r\n                F_DATA:JSON.stringify(f_params)\r\n             }\r\n         }\r\n\r\n         if(f_type==TYPE_ROUTER_PUSH)\r\n             router.push(obj);\r\n         else if(f_type==TYPE_ROUTER_REPLACE)\r\n             router.push(obj);\r\n    }\r\n\r\n    /*\r\n    input:\r\n    data:json={\r\n     f_num:int  defalt -1\r\n    }\r\n     */\r\n    function go(data) {\r\n        var num=-1\r\n        if(data!=undefined)\r\n            num=data['f_num'];\r\n        router.go(num);\r\n    }\r\n    /*\r\n    input:\r\n    data:json={\r\n       array:json array=[\r\n        {\r\n         name:string,\r\n         componet:.vue class\r\n        }\r\n       ]\r\n    }\r\n    out:router array\r\n     */\r\n    function configRouter(data) {\r\n        var array=data['array'];\r\n        var rArray=[]\r\n        array.forEach(function (obj) {\r\n            var name=obj['name'];\r\n            var component=obj['component'];\r\n            var ob={\r\n                path:\"/\"+name+\"/:F_DATA?\",\r\n                name:name,\r\n                component:component,\r\n            }\r\n            rArray.push(ob);\r\n        })\r\n\r\n        return rArray;\r\n    }\r\n\r\n    function setJsonRouter(value) {\r\n        jsonRouter=value;\r\n    }\r\n\r\n    return {\r\n        install:install,\r\n        configRouter:configRouter,\r\n        setJsonRouter:setJsonRouter,\r\n    }\r\n}\r\n\r\nvar ggRouter=router();\r\n\r\nexport {\r\n    VueRouter,\r\n    ggRouter\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/router/router.js"],"sourceRoot":""}